---
title: 'From a laptop centric IDE to project centric IDEs'
date: '2024-5-13'
tags: ['openshift', 'dev spaces', 'developer', 'IDE', 'VDI']
draft: true
summary: 'In this article I am explaining why organizations should provide project specific IDE to their developers (using for example OpenShift Dev Spaces)'
---

Disclaimer: no frogs were hurt in the making of this blog post.

# TL;DR

Developer onboarding, and development activities, are slow down by the defacto approach of a `user centric` IDE: One laptop (or VDI), one IDE.
Change that paradigm to a `project centric` IDE, and you solve all those problems, break project silos, increase security, standardise environment and more.
Solutions like OpenShift Dev Spaces let's you do that. Just do it.

# Introduction

We, developers, have evolved over the last decades, to use more and more advanced IDEs on our laptop. In my generation, emacs was a
great option, still used today, probably not by younger generations who will find the like of Eclipse, VSCode, or Intellij more appealing.
We also evolved in the number of languages, frameworks, libraries, backend services we need to understand, use, and master. In my age,
being good in one language, say C, C++, or Java was plenty to get any job. Nowadays, the list of technical "must have" and "good to have"
requirements listed in any job add is insane. The rise of the full stack developer, jack of all trades, master of none. This got even
more complicated with the microservices architectural style, where microservices are written sometime in different languages, often in different language version,
using different libraries, in different version, relying on different backend services, also in... different versions. Maintaining a development environment
on one's laptop, to cater for this diversity has become a time wasting task, that unnecessary add to the mental load
of developers those days.

I believe, we, developers have been the victims of the so called [boiling frog syndrome](https://en.wikipedia.org/wiki/Boiling_frog): A frog dropped inside a pot full
of safe cold water, which temperature has been increased years after years, without the frog sensing the danger of the water
temperature raising to boiling level, until it's too late for that poor amphibian.

<figure>
  {' '}
  <img
    src="/static/images/devspaces/frog-spa2.webp"
    alt="Frog having a Spa in a cooking pot"
    width="400"
    height="400"
  />
</figure>
{/* ![frogspa](/static/images/devspaces/frog-spa2.webp) */}

It's time to get out of this cooking pot before it's too late, and fix that once and for all.

# Containers to the rescue?

Containerized technology enjoy a massive grow over the last decade. By encapsulating all the requirements of a given applications
(think OS, libraries, runtime environment, code), it ensure safe isolation and portability of that application. Unlike Virtual Machine,
that container is a few order of magnitude faster to start, lighter to store, easier to transport, and agile to work with. It is the
supporting technology that has enable the rise of microservices. Containers are now so ubiquitous, they became the defacto
solution for new project, or solution for legacy project in need of modernisation.

<figure>
  {' '}
  <img
    src="/static/images/devspaces/frog-container.webp"
    alt="Frog saved by a shipping container"
    width="400"
    height="400"
  />
</figure>

{/* ![frogcontainer](/static/images/devspaces/frog-container.webp) */}

This raise the question: If containers are so ubiquitous, if containerized system brings so many benefits, why don't we, developers
use a containerized IDE in the first place?

# OpenShift solution

# Benefits of a set of containerized IDEs

## IDE as code

The same way containers are codified via Dockerfiles, IDE delivered as containers are codified. This is done in several ways:

- Writing your own image, leveraging an existing one (such as Red Hat Universal Developer Image, which upstream project can be found here https://github.com/devfile/developer-images),
  or modifing an existing image (such as Red Hat UDI) to add additional requirements
- Defining sidecar container-components providing additional services for the inner loop development. Think things like databases, webservices, or other CLI tools,
  really anything that can be containerized.
- Defining a libraries of command usefull for all developer working on that particular project

## One project, one IDE

This is maybe the most important benefit. Many developers struggle to maintain their IDE on their laptop, when juggling accross projects, languages, libraries all in different versions.
By containerising for each project, a project specific IDE, we remove all the mental load of fighting dependencies, version conflicts, upgrade, downgrade etc... This is maybe best illustrated by
this xkcd comic IMAGE: https://www.explainxkcd.com/wiki/images/c/cb/python_environment.png

## Instant onboarding

## One project-IDE, many developers

## Security and compliance

By having the code remaining

# OpenShift Dev Spaces solution

## Limitations

# Conclusion

<figure>
  {' '}
  <img
    src="/static/images/devspaces/frog-revolution.webp"
    alt="The Frog Revolution"
    width="400"
    height="400"
  />
</figure>

{/* ![frogrevolution](/static/images/devspaces/frog-revolution.webp) */}
