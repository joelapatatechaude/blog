---
title: 'I benchmarked OpenShift AI Assistant and this is what I found'
date: '2025-04-25'
tags: ['openshift', 'AI', 'lightspeed', 'benchmark']
draft: true
thumbnail: '/static/images/devspaces/frog-spa3.webp'
summary: 'I am using OpenShift LightSpeed AI assistant to solve all the exercises of a troubleshooting tutorial I created last year, and the results are insane.'
---

# TL;DR

The **OpenShift LightSpeed** AI Assistant is ridiculously useful.
Even in its current tech preview phase, I’m already impressed.
OpenShift admins and users are going to love it.
For quick tests or lab environments, you can get it up and running in
minutes by connecting it to OpenAI’s cloud models - gpt-4o mini works perfectly well.
For disconnected clusters or environments where data can’t leave the premises,
adding a GPU to your cluster and deploying a local LLM is the way to go, and it's easy.
A well-trained 8-billion parameter conversational model is more than
sufficient, and **Granite 3.3-8B-Instruct** is my top pick at the time of writing.

<TOCInline toc={props.toc} asDisclosure />

# Introduction

AI assistants are a powerful way to boost productivity.
Yes, their answers still need cross-checking at times—but the pace of improvement is astonishing, and the productivity gains are already real.

In this post, I’ll share the results of a short, **unbiased** benchmark study that highlights how effective
OpenShift LightSpeed (the OpenShift AI Assistant) can be in troubleshooting scenarios.

Why is this benchmark unbiased? Because I created a set of hands-on OpenShift troubleshooting exercises about a year ago,
as a training asset for OpenShift users and admins.
Now that LightSpeed is available, I’m using the exact same scenarios to evaluate its capabilities. No retrofitting or tailored prompts.

The benchmark compares results across three different LLM providers.
LightSpeed itself needs an LLM backend, either cloud-hosted or self-managed, but thanks to its
RAG (Retrieval-Augmented Generation) integration with OpenShift documentation, no model retraining or fine-tuning is needed.

Here are the models I used:

- **OpenAI gpt-4o-mini**: Fast, powerful, affordable, and a leading option in the market. While OpenAI hasn’t disclosed the exact size of the model, it’s estimated to use ~8 billion parameters. It performed extremely well in this benchmark.

- **IBM Granite-3.3-8B-Instruct**: Fully open source and indemnified, two characteristics that appeal to organizations running LLMs in their own data centers. At 8 billion parameters, this model is a solid peer to gpt-4o mini. (Spoiler: it performs just as well.)

- **IBM Granite-3.3-2B-Instruct**: At 2 billion parameters, this model enters CPU-hosted territory. In my CPU tests, it's slow, too slow for a great user experience. But I included it (running on GPU) just to test whether small LLMs can still deliver good results. (Spoiler: not yet.).

What this benchmark is not:

- Not a speed or concurrency test. Both Granite models ran on a single GPU and were fast enough for single-user usage.

- Not a full LLM showdown. The goal is to showcase LightSpeed’s value even on smaller models, not rank every model on the market.

- Not a comparison of LLM servers solutions. I used the open-source vLLM server, where Red Hat (via Neural Magic) is now the top contributor. Quantization support is still maturing, and other servers might be better for large quantized models.

- Not biased. All troubleshooting scenarios were written long before LightSpeed was released. Prompts were initially tested with gpt-4o mini, so it may have a slight edge—but identical prompts were used across all models.

- Not covering all of LightSpeed’s capabilities. This post focuses on troubleshooting. While LightSpeed also answers general OpenShift questions and generates kubernetes YAML resources effectively, that’s outside the scope here.

# Benchmark protocol

This benchmark is based on six troubleshooting exercises (or "tests") that I created over a year ago as part of
a hands-on workshop to help OpenShift users learn how to diagnose and resolve issues.
You can access the full workshop—including instructions, hints, and solutions—here: https://trbl-workshop.cszevaco.com/workshop.

With a good understanding of both how LightSpeed and OpenShift work, and as the original author of the workshop,
I crafted a consistent set of questions to ask the AI assistant.
The answers were assessed based on their accuracy and effectiveness in helping resolve the problem.

For this benchmark,

- I used OpenShift LightSpeed Operator in version 0.3.3, still in tech preview at time of writing. Running on OpenShift 4.18.5
- I used vLLM version: 0.8.4 with GPU support (event for Granite 3.3-2b model)
- The chat history was cleared between each test to avoid context issues.

The table below summarizes the six tests, the context provided
(such as Kubernetes resource YAML, pod logs, and resource events),
the prompts used, and the expected answers.

Note that LightSpeed needs some context (YAML, logs...) to provide troubleshooting guidances specific to the problem at hand.

<table class="table-auto">
{/* <table border="1" cellpadding="8" cellspacing="0"> */}
  <thead>
    <tr>
      <th>Test</th>
      <th>Problem statement</th>
      <th>Context used</th>
      <th>Prompt used</th>
      <th>Expected results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">[1](https://trbl-workshop.cszevaco.com/workshop/exercise_01)</td>
      <td rowspan="2">The deployment specifies an incorrect image name, causing the pod to fail with ImagePullBackOff</td>
      <td rowspan="2">Full Deployment YAML + full Pod YAML + Pod events</td>
      <td>Why is the pod not starting?</td>
      <td>The answer should highlight a possible typo in the image name, show the full image name, and mention other potential causes, while emphasizing the typo as a likely root cause.</td>
    </tr>
    <tr>
      <td>There is a typo in the image name, what is the best approach to fix it?</td>
      <td>The answer should recommend editing the deployment, not the pod, to demonstrate understanding of the deployment-pod relationship.</td>
    </tr>

    <tr>
      <td rowspan="2">[2](https://trbl-workshop.cszevaco.com/workshop/exercise_02)</td>
      <td rowspan="2">The container image has a typo in its entrypoint command (e.g., start vs. starttt), causing the pod to start and crash immediately.</td>
      <td rowspan="2">Full Deployment YAML + full Pod YAML + full Pod log + Pod events</td>
      <td>Why is the pod not starting?</td>
      <td>expected1</td>
    </tr>
    <tr>
      <td>I can't edit the container image, how can I fix the issue?</td>
      <td>expected2</td>
    </tr>

        <tr>
      <td rowspan="5">[3](https://trbl-workshop.cszevaco.com/workshop/exercise_03)</td>
      <td rowspan="5">The pod fails to start due to tight CPU and memory quotas in the namespace. Limits and requests must be tuned, but eventually, the deployment must be scaled down to one replica to fit within the quotas.</td>
      <td>Full Deployment YAML</td>
      <td>Why is the pod not starting?</td>
      <td>expected1</td>
    </tr>
      <tr>
      <td rowspan="2">Adding the namespace resource quotas</td>
      <td>What value do you suggest I should use for the limits and requests?</td>
      <td>expected2</td>
    </tr>
    <tr>
      <td>Since I am running two replicas in the deployment, what value do you suggest I should use?</td>
      <td>expected3</td>
    </tr>
    <tr>
      <td rowspan="2">Adding one failing Pod events + full Pod YAML + full Pod logs</td>
      <td>Why is this pod not starting?</td>
      <td>expected4</td>
    </tr>
      <tr>
      <td>I can't optimize the application resources, and I can't change the resource quotas of the namespace. What are my other options?</td>
      <td>expected5</td>
    </tr>

        <tr>
      <td rowspan="1">[4](https://trbl-workshop.cszevaco.com/workshop/exercise_04)</td>
      <td rowspan="1">The route is unavailable due to two misconfigurations in the service: an incorrect pod selector and an invalid port mapping.</td>
      <td>Full Deployment YAML + full Service YAML + full Route YAML</td>
      <td>Why can't I access this deployment's route?</td>
      <td>expected1</td>
    </tr>

        <tr>
      <td rowspan="2">[5](https://trbl-workshop.cszevaco.com/workshop/exercise_05)</td>
      <td rowspan="2">The pod is unschedulable because the deployment specifies a node selector label that does not exist on any node.</td>
      <td>Full Deployment YAML + full Pod YAML.</td>
      <td>Why is the pod not deploying?</td>
      <td>expected1</td>
    </tr>
    <tr>
      <td>Adding one Node YAML</td>
      <td>There is a policy that forces the use of node selector in the deployment definition. Based on the node definition attached, can you suggest some labels that are likely to be presents in all nodes, so that my pod can be scheduled everywhere?</td>
      <td>expected2</td>
    </tr>

        <tr>
      <td rowspan="3">[6](https://trbl-workshop.cszevaco.com/workshop/exercise_06)</td>
      <td rowspan="3">A namespace is stuck in terminating state due to lingering finalizers that have not been cleared.</td>
      <td>Full Namespace YAML</td>
      <td>Why is this namespace stuck in terminating?</td>
      <td>expected1</td>
    </tr>
    <tr>
      <td rowspan="2">Adding the full PVC YAML</td>
      <td>Why is this PVC stuck in terminating state?</td>
      <td>expected2</td>
    </tr>
    <tr>
      <td>Can you provide me with an openshift command line that identify any pod using this PVC?</td>
      <td>expected3</td>
    </tr>

  </tbody>
</table>

# Results
